import { registerAction } from './actionRegistry';
import { entityStorage } from './storage';
import { emitEntityUpdate } from './entityEvents';
import { logSylviaEvent } from './sylviaLog';
import { awardExperience } from './experience';
import { logContext } from './contextLog';
import { PeopleRecord, GoalRecord, VendorTask } from '../types';

let initialized = false;
let unregisterAll: (() => void)[] = [];

const toUnix = (value?: string): number | undefined => {
  if (!value) return undefined;
  const parsed = Date.parse(value);
  return Number.isNaN(parsed) ? undefined : parsed;
};

const parseScope = (value?: string): 'personal' | 'professional' => {
  if (!value) return 'professional';
  return value.trim().toLowerCase().startsWith('pers') ? 'personal' : 'professional';
};

const parsePriority = (value?: string): 'low' | 'medium' | 'high' => {
  if (!value) return 'medium';
  const normalized = value.trim().toLowerCase();
  if (normalized.startsWith('low')) return 'low';
  if (normalized.startsWith('high')) return 'high';
  return 'medium';
};

const registerJournalAction = () =>
  registerAction({
    id: 'journal.add',
    label: 'Add journal entry',
    handler: async (payload = '') => {
      const [headline, ...rest] = payload.split('\n');
      const body = rest.join('\n').trim() || payload;
      const entry = {
        id: `journal-${Date.now()}`,
        title: headline?.trim() || 'Untitled entry',
        content: body,
        createdAt: Date.now(),
        autoGenerated: true,
      };
      await entityStorage.saveJournalEntry(entry);
      await awardExperience('journal.entry');
      emitEntityUpdate('journal');
      logSylviaEvent({
        kind: 'journal',
        summary: `Journal: ${entry.title}`,
        detail: entry.content.substring(0, 280),
      });
    },
  });

const registerPeopleAction = () =>
  registerAction({
    id: 'people.add',
    label: 'Add person',
    handler: async (payload = '') => {
      // Format: name|role|company|location|email|phone|attributes|profile|notes|tags
      // Attributes and tags are comma-separated
      const parts = payload.split('|');
      const rawName = parts[0]?.trim() || '';
      const rawRole = parts[1]?.trim() || '';
      const rawCompany = parts[2]?.trim() || '';
      const rawLocation = parts[3]?.trim() || '';
      const rawEmail = parts[4]?.trim() || '';
      const rawPhone = parts[5]?.trim() || '';
      const rawAttributes = parts[6]?.trim() || '';
      const rawProfile = parts[7]?.trim() || '';
      const rawNotes = parts[8]?.trim() || '';
      const rawTags = parts[9]?.trim() || '';

      const attributes = rawAttributes
        ? rawAttributes.split(',').map(a => a.trim()).filter(Boolean)
        : undefined;
      const tags = rawTags
        ? rawTags.split(',').map(t => t.trim()).filter(Boolean)
        : undefined;

      const record: PeopleRecord = {
        id: `people-${Date.now()}`,
        name: rawName || 'Unnamed person',
        role: rawRole || undefined,
        company: rawCompany || undefined,
        location: rawLocation || undefined,
        email: rawEmail || undefined,
        phone: rawPhone || undefined,
        attributes,
        profile: rawProfile || undefined,
        notes: rawNotes || undefined,
        tags,
        createdAt: Date.now(),
      };
      await entityStorage.savePeopleRecord(record);
      emitEntityUpdate('people');
      logSylviaEvent({
        kind: 'people',
        summary: `Person logged: ${record.name}`,
        detail: [record.role, record.company, record.attributes?.join(', ')].filter(Boolean).join(' · '),
      });
    },
  });

const registerClientAction = () =>
  registerAction({
    id: 'client.add',
    label: 'Add client',
    handler: async (payload = '') => {
      const [rawName, ...rest] = payload.split('|');
      const record = {
        id: `client-${Date.now()}`,
        name: rawName?.trim() || 'Unnamed client',
        notes: rest.join('|').trim(),
        createdAt: Date.now(),
      };
      await entityStorage.saveClientRecord(record);
      emitEntityUpdate('client');
      logSylviaEvent({
        kind: 'client',
        summary: `Client logged: ${record.name}`,
        detail: record.notes || undefined,
      });
    },
  });

const registerBrandAction = () =>
  registerAction({
    id: 'brand.add',
    label: 'Add brand atom',
    handler: async (payload = '') => {
      const [rawName, ...rest] = payload.split('|');
      const record = {
        id: `brand-${Date.now()}`,
        name: rawName?.trim() || 'Brand element',
        description: rest.join('|').trim(),
        createdAt: Date.now(),
      };
      await entityStorage.saveBrandRecord(record);
      emitEntityUpdate('brand');
      logSylviaEvent({
        kind: 'brand',
        summary: `Brand atom: ${record.name}`,
        detail: record.description,
      });
    },
  });

const registerConceptAction = () =>
  registerAction({
    id: 'concept.add',
    label: 'Add concept',
    handler: async (payload = '') => {
      // Format: name|description|category|tags|notes
      const parts = payload.split('|').map((part) => part.trim());
      const name = parts[0] || 'New concept';
      const description = parts[1] || '';
      const category = parts[2] || undefined;
      const tags = parts[3] ? parts[3].split(',').map(t => t.trim()).filter(Boolean) : undefined;
      const notes = parts[4] || undefined;

      const record: ConceptRecord = {
        id: `concept-${Date.now()}`,
        name,
        description: description || undefined,
        category: category || undefined,
        tags,
        notes: notes || undefined,
        createdAt: Date.now(),
      };
      await entityStorage.saveConceptRecord(record);
      emitEntityUpdate('concept');
      logSylviaEvent({
        kind: 'concept',
        summary: `Concept: ${record.name}`,
        detail: [record.category, record.description?.substring(0, 100)].filter(Boolean).join(' · '),
      });
    },
  });

const registerDeliverableAction = () =>
  registerAction({
    id: 'deliverable.add',
    label: 'Add deliverable',
    handler: async (payload = '') => {
      const [title, description, guardrails, successCriteria, scope, priority, tagsRaw] = payload
        .split('|')
        .map((part) => part.trim());
      const record = {
        id: `deliverable-${Date.now()}`,
        title: title || 'New deliverable',
        description: description || '',
        guardrails: guardrails || '',
        successCriteria: successCriteria || '',
        scope: parseScope(scope),
        priority: parsePriority(priority),
        tags: (tagsRaw || '')
          .split(',')
          .map((tag) => tag.trim())
          .filter(Boolean),
        createdAt: Date.now(),
      };
      await entityStorage.saveDeliverable(record);
      emitEntityUpdate('deliverable');
      logSylviaEvent({
        kind: 'deliverable',
        summary: `Deliverable: ${record.title}`,
        detail: `${record.scope} · ${record.priority}${record.tags.length ? ` · #${record.tags.join(' #')}` : ''}`,
      });
    },
  });

const registerAgendaAction = () =>
  registerAction({
    id: 'agenda.add',
    label: 'Add agenda item',
    handler: async (payload = '') => {
      const [title, dueIso, deliverableId] = payload.split('|').map((part) => part.trim());
      const record = {
        id: `agenda-${Date.now()}`,
        title: title || 'Agenda task',
        status: 'todo' as const,
        dueAt: toUnix(dueIso),
        createdAt: Date.now(),
        deliverableId: deliverableId || undefined,
      };
      await entityStorage.saveAgendaItem(record);
      await awardExperience('agenda.add');
      await logContext('Agenda item created', record.title, {
        scope: 'professional',
        tags: ['agenda', ...(record.deliverableId ? ['deliverable'] : [])],
        metadata: {
          dueAt: dueIso || '',
          deliverableId: record.deliverableId || '',
        },
        autoGenerated: true,
      });
      emitEntityUpdate('agenda');
      logSylviaEvent({
        kind: 'agenda',
        summary: `Agenda: ${record.title}`,
        detail: record.dueAt ? `Due ${new Date(record.dueAt).toLocaleString()}` : undefined,
      });
    },
  });

const registerCalendarAction = () =>
  registerAction({
    id: 'calendar.add',
    label: 'Schedule event',
    handler: async (payload = '') => {
      const [title, startIso, endIso, ...rest] = payload.split('|');
      const event = {
        id: `calendar-${Date.now()}`,
        title: (title || 'Calendar block').trim(),
        startAt: toUnix(startIso?.trim()) || Date.now(),
        endAt: toUnix(endIso?.trim()) || Date.now(),
        description: rest.join('|').trim(),
      };
      await entityStorage.saveCalendarEvent(event);
      emitEntityUpdate('calendar');
      logSylviaEvent({
        kind: 'calendar',
        summary: `Calendar: ${event.title}`,
        detail: `${new Date(event.startAt).toLocaleString()} → ${new Date(event.endAt).toLocaleTimeString()}`,
      });
    },
  });

const registerPomodoroAction = () =>
  registerAction({
    id: 'pomodoro.log',
    label: 'Log pomodoro session',
    handler: async (payload = '') => {
      const [label, minutesRaw] = payload.split('|').map((part) => part.trim());
      const minutes = Number(minutesRaw) || 25;
      const session = {
        id: `pomodoro-${Date.now()}`,
        label: label || 'Focus block',
        startedAt: Date.now(),
        durationMinutes: minutes,
      };
      await entityStorage.savePomodoroSession(session);
      await awardExperience('pomodoro.session');
      emitEntityUpdate('pomodoro');
      logSylviaEvent({
        kind: 'pomodoro',
        summary: `Pomodoro: ${session.label}`,
        detail: `${minutes} min`,
      });
    },
  });

const registerGoalAction = () =>
  registerAction({
    id: 'polaris.goal',
    label: 'Add goal',
    handler: async (payload = '') => {
      // Format: title|description|goalType|metrics|scope|priority
      const parts = payload.split('|').map((part) => part.trim());
      const title = parts[0] || 'New goal';
      const description = parts[1] || '';
      const goalType = (parts[2] === 'big' ? 'big' : 'small') as 'small' | 'big';
      const metrics = parts[3] || '';
      const scope = parseScope(parts[4]);
      const priority = parsePriority(parts[5]);
      const goal: GoalRecord = {
        id: `goal-${Date.now()}`,
        title,
        description,
        goalType,
        metrics,
        scope,
        priority,
        createdAt: Date.now(),
      };
      await entityStorage.saveGoal(goal);
      emitEntityUpdate('goal');
      logSylviaEvent({
        kind: 'goal',
        summary: `Goal: ${goal.title}`,
        detail: `${goal.goalType} · ${goal.scope} · ${goal.priority}`,
      });
    },
  });

const registerVendorTaskAction = () =>
  registerAction({
    id: 'polaris.task',
    label: 'Add vendor task',
    handler: async (payload = '') => {
      // Format: goalId|title|description|rationale|estimatedEffort|estimatedImpact
      const parts = payload.split('|').map((part) => part.trim());
      const goalId = parts[0] || '';
      const title = parts[1] || 'New task';
      const description = parts[2] || '';
      const rationale = parts[3] || '';
      const estimatedEffort = (['very-low', 'low', 'medium', 'high'].includes(parts[4]?.toLowerCase()) 
        ? parts[4].toLowerCase() 
        : 'medium') as VendorTask['estimatedEffort'];
      const estimatedImpact = (['very-low', 'low', 'medium', 'high', 'very-high'].includes(parts[5]?.toLowerCase())
        ? parts[5].toLowerCase()
        : 'medium') as VendorTask['estimatedImpact'];
      
      const task: VendorTask = {
        id: `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        goalId,
        title,
        description,
        rationale: rationale || undefined,
        estimatedEffort,
        estimatedImpact,
        status: 'pending',
        generatedAt: Date.now(),
        createdAt: Date.now(),
      };
      await entityStorage.saveVendorTask(task);
      emitEntityUpdate('goal');
      logSylviaEvent({
        kind: 'goal',
        summary: `Task generated: ${task.title}`,
        detail: `Effort: ${task.estimatedEffort} · Impact: ${task.estimatedImpact}`,
      });
    },
  });

const registerDeleteActions = () => {
  // Delete actions for Sylvia
  const deleteActions = [
    { id: 'people.delete', entityType: 'people', storageFn: entityStorage.deletePeopleRecord.bind(entityStorage) },
    { id: 'brand.delete', entityType: 'brand', storageFn: entityStorage.deleteBrandRecord.bind(entityStorage) },
    { id: 'concept.delete', entityType: 'concept', storageFn: entityStorage.deleteConceptRecord.bind(entityStorage) },
    { id: 'journal.delete', entityType: 'journal', storageFn: entityStorage.deleteJournalEntry.bind(entityStorage) },
    { id: 'calendar.delete', entityType: 'calendar', storageFn: entityStorage.deleteCalendarEvent.bind(entityStorage) },
    { id: 'agenda.delete', entityType: 'agenda', storageFn: entityStorage.deleteAgendaItem.bind(entityStorage) },
    { id: 'deliverable.delete', entityType: 'deliverable', storageFn: entityStorage.deleteDeliverable.bind(entityStorage) },
    { id: 'goal.delete', entityType: 'goal', storageFn: entityStorage.deleteGoal.bind(entityStorage) },
    { id: 'task.delete', entityType: 'task', storageFn: entityStorage.deleteVendorTask.bind(entityStorage) },
  ];

  return deleteActions.map(({ id, entityType, storageFn }) =>
    registerAction({
      id,
      label: `Delete ${entityType}`,
      handler: async (payload = '') => {
        const entityId = payload.trim();
        if (!entityId) {
          throw new Error(`No ${entityType} ID provided`);
        }
        await storageFn(entityId);
        emitEntityUpdate(entityType as any);
        logSylviaEvent({
          kind: entityType as any,
          summary: `Deleted ${entityType}: ${entityId}`,
          detail: `Entity ID: ${entityId}`,
          actionId: id,
          payload: entityId,
        });
      },
    })
  );
};

export const initSylviaActions = () => {
  if (initialized) return;
  unregisterAll = [
    registerJournalAction(),
    registerPeopleAction(),
    registerClientAction(),
    registerBrandAction(),
    registerConceptAction(),
    registerDeliverableAction(),
    registerAgendaAction(),
    registerCalendarAction(),
    registerPomodoroAction(),
    registerGoalAction(),
    registerVendorTaskAction(),
    ...registerDeleteActions(),
  ];
  initialized = true;
};

export const teardownSylviaActions = () => {
  unregisterAll.forEach((fn) => fn());
  unregisterAll = [];
  initialized = false;
};
