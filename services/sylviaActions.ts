import { registerAction } from './actionRegistry';
import { entityStorage } from './storage';
import { emitEntityUpdate } from './entityEvents';
import { logSylviaEvent } from './sylviaLog';
import { awardExperience } from './experience';
import { logContext } from './contextLog';
import { PeopleRecord, GoalRecord, VendorTask, TwitterAccount, TwitterDraft, TwitterScheduledPost, TwitterAnalytics, TwitterList, TwitterHashtagTracker, TwitterMention, TwitterThread, TwitterMetrics } from '../types';

let initialized = false;
let unregisterAll: (() => void)[] = [];

const toUnix = (value?: string): number | undefined => {
  if (!value) return undefined;
  const parsed = Date.parse(value);
  return Number.isNaN(parsed) ? undefined : parsed;
};

const parseScope = (value?: string): 'personal' | 'professional' => {
  if (!value) return 'professional';
  return value.trim().toLowerCase().startsWith('pers') ? 'personal' : 'professional';
};

const parsePriority = (value?: string): 'low' | 'medium' | 'high' => {
  if (!value) return 'medium';
  const normalized = value.trim().toLowerCase();
  if (normalized.startsWith('low')) return 'low';
  if (normalized.startsWith('high')) return 'high';
  return 'medium';
};

const registerJournalAction = () =>
  registerAction({
    id: 'journal.add',
    label: 'Add journal entry',
    handler: async (payload = '') => {
      const [headline, ...rest] = payload.split('\n');
      const body = rest.join('\n').trim() || payload;
      const entry = {
        id: `journal-${Date.now()}`,
        title: headline?.trim() || 'Untitled entry',
        content: body,
        createdAt: Date.now(),
        autoGenerated: true,
      };
      await entityStorage.saveJournalEntry(entry);
      await awardExperience('journal.entry');
      emitEntityUpdate('journal');
      logSylviaEvent({
        kind: 'journal',
        summary: `Journal: ${entry.title}`,
        detail: entry.content.substring(0, 280),
      });
    },
  });

const registerPeopleAction = () =>
  registerAction({
    id: 'people.add',
    label: 'Add person',
    handler: async (payload = '') => {
      // Format: name|role|company|location|email|phone|attributes|profile|notes|tags
      // Attributes and tags are comma-separated
      const parts = payload.split('|');
      const rawName = parts[0]?.trim() || '';
      const rawRole = parts[1]?.trim() || '';
      const rawCompany = parts[2]?.trim() || '';
      const rawLocation = parts[3]?.trim() || '';
      const rawEmail = parts[4]?.trim() || '';
      const rawPhone = parts[5]?.trim() || '';
      const rawAttributes = parts[6]?.trim() || '';
      const rawProfile = parts[7]?.trim() || '';
      const rawNotes = parts[8]?.trim() || '';
      const rawTags = parts[9]?.trim() || '';

      const attributes = rawAttributes
        ? rawAttributes.split(',').map(a => a.trim()).filter(Boolean)
        : undefined;
      const tags = rawTags
        ? rawTags.split(',').map(t => t.trim()).filter(Boolean)
        : undefined;

      const record: PeopleRecord = {
        id: `people-${Date.now()}`,
        name: rawName || 'Unnamed person',
        role: rawRole || undefined,
        company: rawCompany || undefined,
        location: rawLocation || undefined,
        email: rawEmail || undefined,
        phone: rawPhone || undefined,
        attributes,
        profile: rawProfile || undefined,
        notes: rawNotes || undefined,
        tags,
        createdAt: Date.now(),
      };
      await entityStorage.savePeopleRecord(record);
      emitEntityUpdate('people');
      logSylviaEvent({
        kind: 'people',
        summary: `Person logged: ${record.name}`,
        detail: [record.role, record.company, record.attributes?.join(', ')].filter(Boolean).join(' · '),
      });
    },
  });

const registerClientAction = () =>
  registerAction({
    id: 'client.add',
    label: 'Add client',
    handler: async (payload = '') => {
      const [rawName, ...rest] = payload.split('|');
      const record = {
        id: `client-${Date.now()}`,
        name: rawName?.trim() || 'Unnamed client',
        notes: rest.join('|').trim(),
        createdAt: Date.now(),
      };
      await entityStorage.saveClientRecord(record);
      emitEntityUpdate('client');
      logSylviaEvent({
        kind: 'client',
        summary: `Client logged: ${record.name}`,
        detail: record.notes || undefined,
      });
    },
  });

const registerBrandAction = () =>
  registerAction({
    id: 'brand.add',
    label: 'Add brand atom',
    handler: async (payload = '') => {
      const [rawName, ...rest] = payload.split('|');
      const record = {
        id: `brand-${Date.now()}`,
        name: rawName?.trim() || 'Brand element',
        description: rest.join('|').trim(),
        createdAt: Date.now(),
      };
      await entityStorage.saveBrandRecord(record);
      emitEntityUpdate('brand');
      logSylviaEvent({
        kind: 'brand',
        summary: `Brand atom: ${record.name}`,
        detail: record.description,
      });
    },
  });

const registerConceptAction = () =>
  registerAction({
    id: 'concept.add',
    label: 'Add concept',
    handler: async (payload = '') => {
      // Format: name|description|category|tags|notes
      const parts = payload.split('|').map((part) => part.trim());
      const name = parts[0] || 'New concept';
      const description = parts[1] || '';
      const category = parts[2] || undefined;
      const tags = parts[3] ? parts[3].split(',').map(t => t.trim()).filter(Boolean) : undefined;
      const notes = parts[4] || undefined;

      const record: ConceptRecord = {
        id: `concept-${Date.now()}`,
        name,
        description: description || undefined,
        category: category || undefined,
        tags,
        notes: notes || undefined,
        createdAt: Date.now(),
      };
      await entityStorage.saveConceptRecord(record);
      emitEntityUpdate('concept');
      logSylviaEvent({
        kind: 'concept',
        summary: `Concept: ${record.name}`,
        detail: [record.category, record.description?.substring(0, 100)].filter(Boolean).join(' · '),
      });
    },
  });

const registerDeliverableAction = () =>
  registerAction({
    id: 'deliverable.add',
    label: 'Add deliverable',
    handler: async (payload = '') => {
      const [title, description, guardrails, successCriteria, scope, priority, tagsRaw] = payload
        .split('|')
        .map((part) => part.trim());
      const record = {
        id: `deliverable-${Date.now()}`,
        title: title || 'New deliverable',
        description: description || '',
        guardrails: guardrails || '',
        successCriteria: successCriteria || '',
        scope: parseScope(scope),
        priority: parsePriority(priority),
        tags: (tagsRaw || '')
          .split(',')
          .map((tag) => tag.trim())
          .filter(Boolean),
        createdAt: Date.now(),
      };
      await entityStorage.saveDeliverable(record);
      emitEntityUpdate('deliverable');
      logSylviaEvent({
        kind: 'deliverable',
        summary: `Deliverable: ${record.title}`,
        detail: `${record.scope} · ${record.priority}${record.tags.length ? ` · #${record.tags.join(' #')}` : ''}`,
      });
    },
  });

const registerAgendaAction = () =>
  registerAction({
    id: 'agenda.add',
    label: 'Add agenda item',
    handler: async (payload = '') => {
      const [title, dueIso, deliverableId] = payload.split('|').map((part) => part.trim());
      const record = {
        id: `agenda-${Date.now()}`,
        title: title || 'Agenda task',
        status: 'todo' as const,
        dueAt: toUnix(dueIso),
        createdAt: Date.now(),
        deliverableId: deliverableId || undefined,
      };
      await entityStorage.saveAgendaItem(record);
      await awardExperience('agenda.add');
      await logContext('Agenda item created', record.title, {
        scope: 'professional',
        tags: ['agenda', ...(record.deliverableId ? ['deliverable'] : [])],
        metadata: {
          dueAt: dueIso || '',
          deliverableId: record.deliverableId || '',
        },
        autoGenerated: true,
      });
      emitEntityUpdate('agenda');
      logSylviaEvent({
        kind: 'agenda',
        summary: `Agenda: ${record.title}`,
        detail: record.dueAt ? `Due ${new Date(record.dueAt).toLocaleString()}` : undefined,
      });
    },
  });

const registerCalendarAction = () =>
  registerAction({
    id: 'calendar.add',
    label: 'Schedule event',
    handler: async (payload = '') => {
      const [title, startIso, endIso, ...rest] = payload.split('|');
      const event = {
        id: `calendar-${Date.now()}`,
        title: (title || 'Calendar block').trim(),
        startAt: toUnix(startIso?.trim()) || Date.now(),
        endAt: toUnix(endIso?.trim()) || Date.now(),
        description: rest.join('|').trim(),
      };
      await entityStorage.saveCalendarEvent(event);
      emitEntityUpdate('calendar');
      logSylviaEvent({
        kind: 'calendar',
        summary: `Calendar: ${event.title}`,
        detail: `${new Date(event.startAt).toLocaleString()} → ${new Date(event.endAt).toLocaleTimeString()}`,
      });
    },
  });

const registerPomodoroAction = () =>
  registerAction({
    id: 'pomodoro.log',
    label: 'Log pomodoro session',
    handler: async (payload = '') => {
      const [label, minutesRaw] = payload.split('|').map((part) => part.trim());
      const minutes = Number(minutesRaw) || 25;
      const session = {
        id: `pomodoro-${Date.now()}`,
        label: label || 'Focus block',
        startedAt: Date.now(),
        durationMinutes: minutes,
      };
      await entityStorage.savePomodoroSession(session);
      await awardExperience('pomodoro.session');
      emitEntityUpdate('pomodoro');
      logSylviaEvent({
        kind: 'pomodoro',
        summary: `Pomodoro: ${session.label}`,
        detail: `${minutes} min`,
      });
    },
  });

const registerGoalAction = () =>
  registerAction({
    id: 'polaris.goal',
    label: 'Add goal',
    handler: async (payload = '') => {
      // Format: title|description|goalType|metrics|scope|priority
      const parts = payload.split('|').map((part) => part.trim());
      const title = parts[0] || 'New goal';
      const description = parts[1] || '';
      const goalType = (parts[2] === 'big' ? 'big' : 'small') as 'small' | 'big';
      const metrics = parts[3] || '';
      const scope = parseScope(parts[4]);
      const priority = parsePriority(parts[5]);
      const goal: GoalRecord = {
        id: `goal-${Date.now()}`,
        title,
        description,
        goalType,
        metrics,
        scope,
        priority,
        createdAt: Date.now(),
      };
      await entityStorage.saveGoal(goal);
      emitEntityUpdate('goal');
      logSylviaEvent({
        kind: 'goal',
        summary: `Goal: ${goal.title}`,
        detail: `${goal.goalType} · ${goal.scope} · ${goal.priority}`,
      });
    },
  });

const registerVendorTaskAction = () =>
  registerAction({
    id: 'polaris.task',
    label: 'Add vendor task',
    handler: async (payload = '') => {
      // Format: goalId|title|description|rationale|estimatedEffort|estimatedImpact
      const parts = payload.split('|').map((part) => part.trim());
      const goalId = parts[0] || '';
      const title = parts[1] || 'New task';
      const description = parts[2] || '';
      const rationale = parts[3] || '';
      const estimatedEffort = (['very-low', 'low', 'medium', 'high'].includes(parts[4]?.toLowerCase()) 
        ? parts[4].toLowerCase() 
        : 'medium') as VendorTask['estimatedEffort'];
      const estimatedImpact = (['very-low', 'low', 'medium', 'high', 'very-high'].includes(parts[5]?.toLowerCase())
        ? parts[5].toLowerCase()
        : 'medium') as VendorTask['estimatedImpact'];
      
      const task: VendorTask = {
        id: `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        goalId,
        title,
        description,
        rationale: rationale || undefined,
        estimatedEffort,
        estimatedImpact,
        status: 'pending',
        generatedAt: Date.now(),
        createdAt: Date.now(),
      };
      await entityStorage.saveVendorTask(task);
      emitEntityUpdate('goal');
      logSylviaEvent({
        kind: 'goal',
        summary: `Task generated: ${task.title}`,
        detail: `Effort: ${task.estimatedEffort} · Impact: ${task.estimatedImpact}`,
      });
    },
  });

// Twitter/X Actions
const registerTwitterAccountAction = () =>
  registerAction({
    id: 'twitter.account.connect',
    label: 'Connect Twitter account',
    handler: async (payload = '') => {
      // Format: username|displayName|apiKey|apiSecret|accessToken|accessTokenSecret|bearerToken
      const parts = payload.split('|');
      const account: TwitterAccount = {
        id: `twitter-account-${Date.now()}`,
        username: parts[0]?.trim() || '',
        displayName: parts[1]?.trim() || '',
        isConnected: true,
        apiKey: parts[2]?.trim() || undefined,
        apiSecret: parts[3]?.trim() || undefined,
        accessToken: parts[4]?.trim() || undefined,
        accessTokenSecret: parts[5]?.trim() || undefined,
        bearerToken: parts[6]?.trim() || undefined,
        createdAt: Date.now(),
      };
      await entityStorage.saveTwitterAccount(account);
      emitEntityUpdate('twitterAccount');
      logSylviaEvent({
        kind: 'twitter',
        summary: `Connected Twitter account: @${account.username}`,
        detail: account.displayName,
      });
    },
  });

const registerTwitterDraftAction = () =>
  registerAction({
    id: 'twitter.draft.create',
    label: 'Create Twitter draft',
    handler: async (payload = '') => {
      // Format: content|isThread|tags|threadTweets (pipe-separated for tweets if thread)
      const parts = payload.split('||');
      const [contentAndMeta, ...threadTweets] = parts;
      const [content, isThread, tags] = contentAndMeta.split('|');

      const draft: TwitterDraft = {
        id: `twitter-draft-${Date.now()}`,
        content: content?.trim() || '',
        isThread: isThread?.trim().toLowerCase() === 'true',
        tags: tags ? tags.split(',').map(t => t.trim()).filter(Boolean) : undefined,
        threadTweets: threadTweets.length > 0 ? threadTweets.map(t => t.trim()).filter(Boolean) : undefined,
        createdAt: Date.now(),
      };
      await entityStorage.saveTwitterDraft(draft);
      emitEntityUpdate('twitterDraft');
      logSylviaEvent({
        kind: 'twitter',
        summary: `Twitter draft created${draft.isThread ? ' (Thread)' : ''}`,
        detail: draft.content.substring(0, 100),
      });
    },
  });

const registerTwitterScheduleAction = () =>
  registerAction({
    id: 'twitter.schedule.create',
    label: 'Schedule Twitter post',
    handler: async (payload = '') => {
      // Format: content|scheduledAt|tags|isThread|threadTweets
      const parts = payload.split('||');
      const [contentAndMeta, ...threadTweets] = parts;
      const [content, scheduledAt, tags, isThread] = contentAndMeta.split('|');

      const post: TwitterScheduledPost = {
        id: `twitter-scheduled-${Date.now()}`,
        content: content?.trim() || '',
        scheduledAt: toUnix(scheduledAt) || Date.now() + 3600000, // Default 1 hour from now
        status: 'pending',
        tags: tags ? tags.split(',').map(t => t.trim()).filter(Boolean) : undefined,
        threadTweets: threadTweets.length > 0 && isThread?.trim().toLowerCase() === 'true'
          ? threadTweets.map(t => t.trim()).filter(Boolean)
          : undefined,
        createdAt: Date.now(),
      };
      await entityStorage.saveTwitterScheduledPost(post);
      emitEntityUpdate('twitterScheduled');
      logSylviaEvent({
        kind: 'twitter',
        summary: `Scheduled tweet for ${new Date(post.scheduledAt).toLocaleString()}`,
        detail: post.content.substring(0, 100),
      });
    },
  });

const registerTwitterAnalyticsAction = () =>
  registerAction({
    id: 'twitter.analytics.log',
    label: 'Log Twitter analytics',
    handler: async (payload = '') => {
      // Format: tweetId|impressions|engagements|likes|retweets|replies|permalink
      const parts = payload.split('|');
      const analytics: TwitterAnalytics = {
        id: `twitter-analytics-${Date.now()}`,
        tweetId: parts[0]?.trim() || '',
        impressions: parseInt(parts[1]?.trim() || '0') || undefined,
        engagements: parseInt(parts[2]?.trim() || '0') || undefined,
        likes: parseInt(parts[3]?.trim() || '0') || undefined,
        retweets: parseInt(parts[4]?.trim() || '0') || undefined,
        replies: parseInt(parts[5]?.trim() || '0') || undefined,
        permalink: parts[6]?.trim() || undefined,
        fetchedAt: Date.now(),
        createdAt: Date.now(),
      };
      await entityStorage.saveTwitterAnalytics(analytics);
      emitEntityUpdate('twitterAnalytics');
      logSylviaEvent({
        kind: 'twitter',
        summary: `Analytics logged for tweet ${analytics.tweetId}`,
        detail: `${analytics.impressions} impressions, ${analytics.engagements} engagements`,
      });
    },
  });

const registerTwitterListAction = () =>
  registerAction({
    id: 'twitter.list.add',
    label: 'Add Twitter list',
    handler: async (payload = '') => {
      // Format: listId|name|description|memberCount|subscriberCount|isPrivate
      const parts = payload.split('|');
      const list: TwitterList = {
        id: `twitter-list-${Date.now()}`,
        listId: parts[0]?.trim() || '',
        name: parts[1]?.trim() || 'Untitled List',
        description: parts[2]?.trim() || undefined,
        memberCount: parseInt(parts[3]?.trim() || '0') || undefined,
        subscriberCount: parseInt(parts[4]?.trim() || '0') || undefined,
        isPrivate: parts[5]?.trim().toLowerCase() === 'true',
        createdAt: Date.now(),
      };
      await entityStorage.saveTwitterList(list);
      emitEntityUpdate('twitterList');
      logSylviaEvent({
        kind: 'twitter',
        summary: `Twitter list added: ${list.name}`,
        detail: list.description,
      });
    },
  });

const registerTwitterHashtagAction = () =>
  registerAction({
    id: 'twitter.hashtag.track',
    label: 'Track Twitter hashtag',
    handler: async (payload = '') => {
      // Format: hashtag|notes
      const parts = payload.split('|');
      const tracker: TwitterHashtagTracker = {
        id: `twitter-hashtag-${Date.now()}`,
        hashtag: parts[0]?.trim().replace(/^#/, '') || '',
        isActive: true,
        trackingStartedAt: Date.now(),
        notes: parts[1]?.trim() || undefined,
        createdAt: Date.now(),
      };
      await entityStorage.saveTwitterHashtagTracker(tracker);
      emitEntityUpdate('twitterHashtag');
      logSylviaEvent({
        kind: 'twitter',
        summary: `Tracking hashtag: #${tracker.hashtag}`,
        detail: tracker.notes,
      });
    },
  });

const registerTwitterMentionAction = () =>
  registerAction({
    id: 'twitter.mention.log',
    label: 'Log Twitter mention',
    handler: async (payload = '') => {
      // Format: tweetId|authorUsername|authorDisplayName|content|permalink
      const parts = payload.split('|');
      const mention: TwitterMention = {
        id: `twitter-mention-${Date.now()}`,
        tweetId: parts[0]?.trim() || '',
        authorUsername: parts[1]?.trim() || '',
        authorDisplayName: parts[2]?.trim() || '',
        content: parts[3]?.trim() || '',
        permalink: parts[4]?.trim() || undefined,
        isRead: false,
        repliedTo: false,
        createdAt: Date.now(),
      };
      await entityStorage.saveTwitterMention(mention);
      emitEntityUpdate('twitterMention');
      logSylviaEvent({
        kind: 'twitter',
        summary: `New mention from @${mention.authorUsername}`,
        detail: mention.content.substring(0, 100),
      });
    },
  });

const registerTwitterThreadAction = () =>
  registerAction({
    id: 'twitter.thread.create',
    label: 'Create Twitter thread',
    handler: async (payload = '') => {
      // Format: title|status|tags||tweet1||tweet2||tweet3...
      const parts = payload.split('||');
      const [metaPart, ...tweetParts] = parts;
      const [title, status, tags] = metaPart.split('|');

      const thread: TwitterThread = {
        id: `twitter-thread-${Date.now()}`,
        title: title?.trim() || undefined,
        status: (status?.trim() as 'draft' | 'scheduled' | 'posted') || 'draft',
        tags: tags ? tags.split(',').map(t => t.trim()).filter(Boolean) : undefined,
        tweets: tweetParts.map(t => ({ content: t.trim() })).filter(t => t.content),
        createdAt: Date.now(),
      };
      await entityStorage.saveTwitterThread(thread);
      emitEntityUpdate('twitterThread');
      logSylviaEvent({
        kind: 'twitter',
        summary: `Thread created: ${thread.title || 'Untitled'}`,
        detail: `${thread.tweets.length} tweets`,
      });
    },
  });

const registerTwitterMetricsAction = () =>
  registerAction({
    id: 'twitter.metrics.log',
    label: 'Log Twitter metrics',
    handler: async (payload = '') => {
      // Format: date|followers|following|totalTweets|totalImpressions|totalEngagements
      const parts = payload.split('|');
      const metrics: TwitterMetrics = {
        id: `twitter-metrics-${Date.now()}`,
        date: parts[0]?.trim() || new Date().toISOString().split('T')[0],
        followers: parseInt(parts[1]?.trim() || '0') || 0,
        following: parseInt(parts[2]?.trim() || '0') || 0,
        totalTweets: parseInt(parts[3]?.trim() || '0') || 0,
        totalImpressions: parseInt(parts[4]?.trim() || '0') || undefined,
        totalEngagements: parseInt(parts[5]?.trim() || '0') || undefined,
        createdAt: Date.now(),
      };
      await entityStorage.saveTwitterMetrics(metrics);
      emitEntityUpdate('twitterMetrics');
      logSylviaEvent({
        kind: 'twitter',
        summary: `Metrics logged for ${metrics.date}`,
        detail: `${metrics.followers} followers, ${metrics.totalTweets} tweets`,
      });
    },
  });

const registerDeleteActions = () => {
  // Delete actions for Sylvia
  const deleteActions = [
    { id: 'people.delete', entityType: 'people', storageFn: entityStorage.deletePeopleRecord.bind(entityStorage) },
    { id: 'brand.delete', entityType: 'brand', storageFn: entityStorage.deleteBrandRecord.bind(entityStorage) },
    { id: 'concept.delete', entityType: 'concept', storageFn: entityStorage.deleteConceptRecord.bind(entityStorage) },
    { id: 'journal.delete', entityType: 'journal', storageFn: entityStorage.deleteJournalEntry.bind(entityStorage) },
    { id: 'calendar.delete', entityType: 'calendar', storageFn: entityStorage.deleteCalendarEvent.bind(entityStorage) },
    { id: 'agenda.delete', entityType: 'agenda', storageFn: entityStorage.deleteAgendaItem.bind(entityStorage) },
    { id: 'deliverable.delete', entityType: 'deliverable', storageFn: entityStorage.deleteDeliverable.bind(entityStorage) },
    { id: 'goal.delete', entityType: 'goal', storageFn: entityStorage.deleteGoal.bind(entityStorage) },
    { id: 'task.delete', entityType: 'task', storageFn: entityStorage.deleteVendorTask.bind(entityStorage) },
    { id: 'twitter.draft.delete', entityType: 'twitterDraft', storageFn: entityStorage.deleteTwitterDraft.bind(entityStorage) },
    { id: 'twitter.scheduled.delete', entityType: 'twitterScheduled', storageFn: entityStorage.deleteTwitterScheduledPost.bind(entityStorage) },
    { id: 'twitter.list.delete', entityType: 'twitterList', storageFn: entityStorage.deleteTwitterList.bind(entityStorage) },
    { id: 'twitter.hashtag.delete', entityType: 'twitterHashtag', storageFn: entityStorage.deleteTwitterHashtagTracker.bind(entityStorage) },
    { id: 'twitter.thread.delete', entityType: 'twitterThread', storageFn: entityStorage.deleteTwitterThread.bind(entityStorage) },
  ];

  return deleteActions.map(({ id, entityType, storageFn }) =>
    registerAction({
      id,
      label: `Delete ${entityType}`,
      handler: async (payload = '') => {
        const entityId = payload.trim();
        if (!entityId) {
          throw new Error(`No ${entityType} ID provided`);
        }
        await storageFn(entityId);
        emitEntityUpdate(entityType as any);
        logSylviaEvent({
          kind: entityType as any,
          summary: `Deleted ${entityType}: ${entityId}`,
          detail: `Entity ID: ${entityId}`,
          actionId: id,
          payload: entityId,
        });
      },
    })
  );
};

export const initSylviaActions = () => {
  if (initialized) return;
  unregisterAll = [
    registerJournalAction(),
    registerPeopleAction(),
    registerClientAction(),
    registerBrandAction(),
    registerConceptAction(),
    registerDeliverableAction(),
    registerAgendaAction(),
    registerCalendarAction(),
    registerPomodoroAction(),
    registerGoalAction(),
    registerVendorTaskAction(),
    registerTwitterAccountAction(),
    registerTwitterDraftAction(),
    registerTwitterScheduleAction(),
    registerTwitterAnalyticsAction(),
    registerTwitterListAction(),
    registerTwitterHashtagAction(),
    registerTwitterMentionAction(),
    registerTwitterThreadAction(),
    registerTwitterMetricsAction(),
    ...registerDeleteActions(),
  ];
  initialized = true;
};

export const teardownSylviaActions = () => {
  unregisterAll.forEach((fn) => fn());
  unregisterAll = [];
  initialized = false;
};
